\documentclass[10pt,letterpaper,unboxed,cm]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\usepackage[normalem]{ulem}
\usepackage{latexsym}
\usepackage{xcolor}
\usepackage{color}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{siunitx}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{cleveref}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{tcolorbox}

\newcommand{\tab}{~~~~}

\begin{document}
\begin{center}
    \textbf{\Large{CSE 110 Notes}}
\end{center}
\section{9/27}
Why is it so hard to properly get a software project done?\\
\begin{itemize}
    \item Scale - larger projects require more time; the longer it takes, the less likely the estimated time will be accurate
    \begin{itemize}
        \item More likely to be cancelled
    \end{itemize}
    \item Misunderstood and changing requirements - if software is already in operation, the cost to change it is higher
\end{itemize}
Class is meant to help deliver larger and better quality software projects\\
Quality control - early manufacturing revolved around:\\
\begin{itemize}
    \item Inspecting the product
    \item Fixing the product
    \item Reworking the production line
\end{itemize}
Led to Process-centric quality control\\
Still test the product, but also measure the process elements\\
Use cause-and-effect model to adjust production process\\
Statistical Process Control (SPC) - use statistics to track production variation\\
SE is Process-centric\\\\
What is a Software Process?\\
Produce quality software - what the customer wants, on time, under budget, no flaws\\
Steps include planning, execution, and measurement of product and process, and improvement\\\\
Discusses techniques for managing scale and risk/uncertainty\\
Process is just the beginning; also about quality decision-making\\
Needs good architecture, design, teamwork, and quality assurance\\\\
How to built what is needed, vs what is thought to be needed? Through frequent iteration and feedback from users\\
Robust code through good design and architecture\\\\
Project is self-decided\\
As long as choices make sense, you can get an A\\
Each student is graded on contributions to the team\\
Wisdom is better than quantity\\\\
Goals of the course: \\
Work effectively in a team using Agile development process\\
Design and document software systems according to stakeholder needs\\
Implement and debug complex software systems\\
Think about tradeoffs and risks\\\\
Courses need to teach technologies and principles, but principles need to be taught in context\\
Lecture focuses on principles, lab focuses on technologies\\
Team project: you choose the requirements\\
TA to manage project\\
Graded on ongoing quality and progress\\
Submit peer feedback every week, and TAs will give scores in Independence, Teamwork, and Technical contributions\\
\textbf{Focus groups} to provide insight regarding what users want\\
\textbf{Vision document} to say what you plan to create\\
A \textbf{mockup} will show the application in detail\\
In \textbf{five sprints}, build the app\\
\section{9/30}
\textbf{Requirements Engineering} - trying to figure out what is needed and record that down to communicate to the team\\
Goal is to elicit requirements from stakeholders through interviews\\
Write user stories according to the INVEST criteria\\
Stakeholder: "person with an interest or concern in something, particularly a business"\\
Methods: \\
Survey -- might not know what to count\\
Interviews -- better\\
Focus groups -- more participants, less time, but quiet people may not be heard\\
How to write questions: \\
Can cause biases if the wording is not neutral\\
Needs to be simple, open-ended, speak the user's language, and ask for demonstrations or recall of concrete events\\
Recording data: write notes, or record audio and transcribe\\
Rapport: Be non-judgmental\\
Conducting the interview: \\
\tab Start with easy questions\\
\tab Listen and provide opportunities for the interviewee to continue\\
\tab Ask for clarification\\
Express requirements as User Stories - "As a [role], I want [something] so that [need]"\\
User story criteria: INVEST\\
Independent, Negotiable, Valuable, Estimable, Small, Testable\\
\tab Independent: want to implement requirements in any order - helps with collaboration\\
\tab Negotiable: can be changed during development; user story doesn't specify everything\\
\tab Valuable: provides value to the user\\
\tab Estimable: keeps the size small, need to complete user story in 1-2 weeks or less\\
\tab Small: Fit on a 3x5 card, at most two person-weeks of work -- too big means unable to estimate, can't finish in time for delivery\\
\tab Testable: can be tested to see if it is done or not\\
\section{10/2}
What makes software great?\\
\tab User stories aren't enough -- lots of ways to write the code\\
\tab How to figure out which implementation is desided?\\
\tab Goal is to learn \textit{abstraction} - key to writing good software\\
\tab Learn key principles for making software maintainable\\
Quality Attributes: \\
\tab Express "non-functional" requirements\\
\tab Not what the system should do, but how it should do it\\
\tab Examples: modifiability, maintainability, performance, robustness\\
\tab Good design promotes some quality attributes, sometimes at the expense of other\\
High level design is called "architecture"\\
SOLID Principles for Design:\\
\tab Single Responsibility Principle (SRP): a class should be responsible for one thing\\
\begin{itemize}
    \item Thing, capability, computation
    \item Object only does its own calculations
    \item Don't cram related functionality into one class
    \item Helps know where to find code and prevents propogation of mistakes
\end{itemize}
\tab Open/Closed Principle: a class should be open for extension, but closed for modification
\begin{itemize}
    \item Can extend class without modifying it
\end{itemize}
\tab Liskov Substitution Principle: properties of a class should hold of subclasses
\begin{itemize}
    \item Subclasses should be able to be used in place of the superclass
\end{itemize}
\tab Interface Segregation Principle: clients shouldn't have to implement interfaces/depend on methods they don't use
\tab Dependency Inversion Principle: high-level modules should not depend on low-level modules; both should depend on abstractions
\begin{itemize}
    \item Abstractions should not depend on details; details should depend on abstractions
    \item Goal is to avoid tight coupling
\end{itemize}
DRY: Don't Repeat Yourself\\
Each thing or computational idea should be expressed just once in the code\\
\tab Violations are the result of copy-pasting code or incomplete classes (violate SRP), but also over-specialization of classes\\
\section{10/4}
React\\
Learn the HTML Document Object Model (DOM)\\
What are web apps? Website that changes depending on what the user does - dynamic web site\\
\tab Content is interactive\\
Webpages are trees\\
Old way was to remake the tree and reload the page\\
Modern way is to manipulate the DOM\\
React: don't write HTML directly, write code that emits HTML\\
\tab React is a framework\\
\tab A software framework is an abstraction in which software, probiding generic functionality, can be selectively changed with additional user specified code\\
Instead of writing code in order, write the functions, and framework calls functions in the right order\\
Frameworks are "opinionated" - designer of a framework has a way they want you to write code\\
Benefits of a framework: \\
\tab Provides useful defaults, standard behaviour
Downsides: \\
Have to understand how the framework works\\
Knowledge will be incomplete\\
\section{10/7}
Design Patterns\\
Same problems in multiple contexts\\
"each pattern represents our current best guess as to what arrangement of the physical environment will work to solve the problem presented. The empirical
questions center on the problem---does it occur and is it felt in the way we describe it? ---and the solution---does the arrangement we propose solve the problem?"\\
Object-oriented design patterns: so common\\
Each pattern solves certain problems, but not all problems can be solved with named patterns\\
Factory pattern: \\
\tab Object needs to be hooked up, or which object to create depends on something\\
\tab Repeating this pattern violates DRY, so put the logic in a "factory"\\
Singleton Pattern:\\
\tab Sometimes there should only be one of something - only one "factory"\\
\tab Other examples: logger, cache, thread pool\\
\tab Use sparingly; a lot like global variables\\
\tab Private constructors are a good example\\
Observer Pattern:\\
\tab Multiple different ways to update one model - different controllers\\
\tab Model stores state\\
\tab Views need to know state, but the model shouldn't have to communicate to the different views through controllers\\
\tab Controllers have to know about the model, but the model shouldn't have to know about the controllers\\
\tab Model has a notification center, and the controllers \textbf{listen} to the notification center\\
\tab Controllers are the Observers
\section{10/9}
Why study HCI?
\tab Software Engineering is about meeting user Needs\\
\tab Building the wrong software is costly\\
\tab Apply principles of HCI, iterate, hire a designer\\
Contextual design: People are experts at their own work, but can't articulate their work process\\
\tab Observe people in their work environment\\
\tab Build personas to bring users alive\\
\tab \tab Personas build empathy, help you think like the user, but are not necessarily real people\\
\tab Design a prototype with Figma\\
Principles: \\
\tab Ways of assessing designs: usability studies, "discount methods" (users are expensive)\\
Nielsen's 10 Usability Heuristics: \\
\tab From 1994, but still relevant\\
\tab No need for user tests, instead, need an expert evaluator\\
\tab Goal is to identify usability problems\\
\begin{itemize}
    \item Visibility of system status: keep users informed about what is going on; progress indicators
    \item Match between system and the real world: speak the user's language, follow real-world conventions
    \item User control and freedom: undo, redo, escape, exit
    \item Consistency and standards: follow platform conventions - people use other products more than yours
    \item Error prevention: eliminate error-prone conditions, check for errors, confirm before destructive actions
    \item Recognition rather than recall: minimize memory load, make objects, actions, and options visible
    \item Flexibility and efficiency of use: accelerators, shortcuts (hidden from novice users), allow users to tailor frequent actions: 
    novices need discoverability; experts need efficiency
    \item Aesthetic and minimalist design: don't include information that is irrelevant or rarely needed
    \item Help users recognize, diagnose, and recover from errors: error messages in plain language, precisely indicate the problem, constructively suggest a solution
    \item Help and documentation: even though it is better if the system can be used without documentation, it may be necessary to provide help and documentation:
    enable search in documentation, present documentation in context
    \begin{itemize}
        \item Proactive help: provide help before the user gets stuck (tutorials): Push - not relevant to user goals, pull - relevant to user goals
        \item Reactive help: provide help when the user gets stuck (error messages, FAQ)
    \end{itemize}
\end{itemize}
\section{10/14}
Process: \\
\tab Software Process: a set of activities and associated results that produce a software product\\
How to develop software?\\
\tab Discuss the software that needs to be written\\
\tab write some code\\
\tab test the code\\
\tab debug the code to find causes of defects\\
\tab fix the bugs
Productive development: (coding, testing, making progress towards goals)\\
Not spending effort into addressing inefficiences and following process leads to more work later on\\
Hypothesis: Process increases efficiency and flexibility\\
\tab Ideal curve is upfront investment in process for later returns\\
Estimating time is hard\\
How to measure progress?\\
\tab Developer judgement, lines of code, functionality, quality\\
Milestones and Deliverables make progress observable\\
Milestone: Clear end point of a (sub)task(s)\\
\tab For a project manager; reports, prototypes, completed subprojects\\
Deliverables: Result for customer\\
\tab Similar to milestones, but for customers\\
Waterfall Model: \\
\tab Requirements, design, implement, verification, maintenance\\
Need to center around rapid feedback instead\\
Lean production: adapt to variable demand\\
\tab Build only what is needed, when it is needed\\
\tab Use "pull" system to avoid overproduction\\
\tab Stop to fix problems to prevent defects from propogating\\
\tab Workers are multi-skilled and can understand the whole process; take ownership\\
\tab \tab Just-in-time, DevOps, Shift-Left\\\\
Agile Overview: \\
\tab Keep a prioritized list of user stories in a backlog\\
\tab \textbf{Product owner} sets priorities in backlog\\
\tab Divide work into sprints (2ish weeks)\\
\tab Conceptually, at the end of each sprint, you could ship\\
\tab The \textbf{scrum master} keeps progress on track; removes barriers to success\\\\
Sprint structure: \\
\tab Start with planning meeting\\
\tab Estimate user stories, commit to them individually\\
\tab Daily standup meetings: what did I do yesterday, what will I do today, am I stuck\\
\tab Then sprint review and sprint retrospective\\\\
Sprint Review: \\
\tab For each user story, demo\\
\tab If acceptance criteria are met, story is done, else it goes back to the backlog\\\\
Sprint Retrospective: \\
\tab Discuss how the sprint went, refine iterations, processes, tools; identify and solve problems; decide on changes to improve effectiveness\\
\section{10/16}
Testing:\\
\tab Defining correct behaviour\\
Purposes of testing: \\
\tab Find bugs\\
\tab Prevent bugs from sneaking in when enhancing\\
\tab Give high confidence in correctness\\
\tab Explore class/method design\\
\tab Specify expected behaviour\\
Three big ideas: \\
\tab Coverage: seek to execute all possibilities\\
\tab Test equivalence classes: tests should all cover different things\\
\tab Bottom-up testing: test the smallest things first, when testing things you shouldn't have to test the components\\
Black box vs White box testing: \\
\tab Black box: test the software without knowing the internal structure\\
\tab \tab Not biased by implementation details, can't leverage opportunities\\
\tab White box: test the software with knowledge of the internal structure\\
\tab \tab Can exploit bugs, will miss "impossible" bugs\\
Agile Testing (hierarchical, diverse): \\
\tab 3 kinds of tests, bottom up: \\
\tab \tab Unit tests: test individual classes and methods (task level)\\
\tab \tab Integration tests: test how classes work together, BDD personality tests (story level)\\
\tab \tab End-to-end scenario tests: (milestone level)\\
Mocking as a way to test\\
\tab Testing can only show the presence of bugs, not the absence\\
Fuzz testing: security and robustness\\
\tab Bugs don't always result in crashes\\
\tab \tab Automatic oracles: sanitizers\\
Pros: cheap to generate inputs, easy to debug when issues are found\\
Cons: hard to know when to stop, hard to know if you've found all the bugs, random inputs don't make sense\\
\section{10/18}
Software Architecture:\\
\tab High-level design of a software system\\
\tab Structure of the system, includes software elements, externally visible properties, relationships between them\\
Two kinds of requirements: \\
\tab Functional requirements: what the system should do\\
\tab Quality attributes: the degree to which the software works as needed\\
\tab \tab Modifiability, performance, scalability, availabilty, usability, maintainability, etc.\\
Levels of abstraction: \\
\tab Requirements: what needs to be done\\
\tab Architecture: how it will be done, mid-level "what"\\
\tab OO-Design (low level): mid-level how it will be done, low-level "what"\\
Views: \\
\tab Different ways of looking at the same system\\
Why document architecture?\\
\tab Blueprint for the system, helps with maintenance\\
\tab Documents architect's knowledge/decisions\\
\tab Supports traceability\\
Each view alights with a purpose\\
\tab Only represents info relevant to the purpose\\
\tab Different views for different reasoning models\\
Module views (static): \\
\tab Shows structure defined by the code\\
\tab Modules (systems, subsystems) and their relations (dependencies)\\
\tab Often shows decompositions (what contains what) and uses (what calls what)\\
\tab \tab Composition: has to include the other\\
\tab \tab Aggregation: can exist without the other\\
\tab UML for the diagram\\
Component views (dynamic): \\
\tab Shows entities at runtime\\
\tab Components (processes, runnable entities) and their connectors (data flow, messages)\\
\tab Do not exist until program runs, can't be shown in static view\\
Physical view (deployment): \\
\tab Hardware structures and their components\\
\tab What parts of the system run on which physical machines\\
\tab How do those machines connect\\

\end{document}
