\documentclass[10pt,letterpaper,unboxed,cm]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\usepackage[normalem]{ulem}
\usepackage{latexsym}
\usepackage{xcolor}
\usepackage{color}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{siunitx}
\usepackage{enumitem}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{cleveref}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{tcolorbox}

\newcommand{\tab}{~~~~}

\begin{document}
\begin{center}
    \textbf{\Large{CSE 110 Notes}}
\end{center}
\section{9/27}
Why is it so hard to properly get a software project done?\\
\begin{itemize}
    \item Scale - larger projects require more time; the longer it takes, the less likely the estimated time will be accurate
    \begin{itemize}
        \item More likely to be cancelled
    \end{itemize}
    \item Misunderstood and changing requirements - if software is already in operation, the cost to change it is higher
\end{itemize}
Class is meant to help deliver larger and better quality software projects\\
Quality control - early manufacturing revolved around:\\
\begin{itemize}
    \item Inspecting the product
    \item Fixing the product
    \item Reworking the production line
\end{itemize}
Led to Process-centric quality control\\
Still test the product, but also measure the process elements\\
Use cause-and-effect model to adjust production process\\
Statistical Process Control (SPC) - use statistics to track production variation\\
SE is Process-centric\\\\
What is a Software Process?\\
Produce quality software - what the customer wants, on time, under budget, no flaws\\
Steps include planning, execution, and measurement of product and process, and improvement\\\\
Discusses techniques for managing scale and risk/uncertainty\\
Process is just the beginning; also about quality decision-making\\
Needs good architecture, design, teamwork, and quality assurance\\\\
How to built what is needed, vs what is thought to be needed? Through frequent iteration and feedback from users\\
Robust code through good design and architecture\\\\
Project is self-decided\\
As long as choices make sense, you can get an A\\
Each student is graded on contributions to the team\\
Wisdom is better than quantity\\\\
Goals of the course: \\
Work effectively in a team using Agile development process\\
Design and document software systems according to stakeholder needs\\
Implement and debug complex software systems\\
Think about tradeoffs and risks\\\\
Courses need to teach technologies and principles, but principles need to be taught in context\\
Lecture focuses on principles, lab focuses on technologies\\
Team project: you choose the requirements\\
TA to manage project\\
Graded on ongoing quality and progress\\
Submit peer feedback every week, and TAs will give scores in Independence, Teamwork, and Technical contributions\\
\textbf{Focus groups} to provide insight regarding what users want\\
\textbf{Vision document} to say what you plan to create\\
A \textbf{mockup} will show the application in detail\\
In \textbf{five sprints}, build the app\\
\section{9/30}
\textbf{Requirements Engineering} - trying to figure out what is needed and record that down to communicate to the team\\
Goal is to elicit requirements from stakeholders through interviews\\
Write user stories according to the INVEST criteria\\
Stakeholder: "person with an interest or concern in something, particularly a business"\\
Methods: \\
Survey -- might not know what to count\\
Interviews -- better\\
Focus groups -- more participants, less time, but quiet people may not be heard\\
How to write questions: \\
Can cause biases if the wording is not neutral\\
Needs to be simple, open-ended, speak the user's language, and ask for demonstrations or recall of concrete events\\
Recording data: write notes, or record audio and transcribe\\
Rapport: Be non-judgmental\\
Conducting the interview: \\
\tab Start with easy questions\\
\tab Listen and provide opportunities for the interviewee to continue\\
\tab Ask for clarification\\
Express requirements as User Stories - "As a [role], I want [something] so that [need]"\\
User story criteria: INVEST\\
Independent, Negotiable, Valuable, Estimable, Small, Testable\\
\tab Independent: want to implement requirements in any order - helps with collaboration\\
\tab Negotiable: can be changed during development; user story doesn't specify everything\\
\tab Valuable: provides value to the user\\
\tab Estimable: keeps the size small, need to complete user story in 1-2 weeks or less\\
\tab Small: Fit on a 3x5 card, at most two person-weeks of work -- too big means unable to estimate, can't finish in time for delivery\\
\tab Testable: can be tested to see if it is done or not\\
\section{10/2}
What makes software great?\\
\tab User stories aren't enough -- lots of ways to write the code\\
\tab How to figure out which implementation is desided?\\
\tab Goal is to learn \textit{abstraction} - key to writing good software\\
\tab Learn key principles for making software maintainable\\
Quality Attributes: \\
\tab Express "non-functional" requirements\\
\tab Not what the system should do, but how it should do it\\
\tab Examples: modifiability, maintainability, performance, robustness\\
\tab Good design promotes some quality attributes, sometimes at the expense of other\\
High level design is called "architecture"\\
SOLID Principles for Design:\\
\tab Single Responsibility Principle (SRP): a class should be responsible for one thing\\
\begin{itemize}
    \item Thing, capability, computation
    \item Object only does its own calculations
    \item Don't cram related functionality into one class
    \item Helps know where to find code and prevents propogation of mistakes
\end{itemize}
\tab Open/Closed Principle: a class should be open for extension, but closed for modification
\begin{itemize}
    \item Can extend class without modifying it
\end{itemize}
\tab Liskov Substitution Principle: properties of a class should hold of subclasses
\begin{itemize}
    \item Subclasses should be able to be used in place of the superclass
\end{itemize}
\tab Interface Segregation Principle: clients shouldn't have to implement interfaces/depend on methods they don't use
\tab Dependency Inversion Principle: high-level modules should not depend on low-level modules; both should depend on abstractions
\begin{itemize}
    \item Abstractions should not depend on details; details should depend on abstractions
    \item Goal is to avoid tight coupling
\end{itemize}
DRY: Don't Repeat Yourself\\
Each thing or computational idea should be expressed just once in the code\\
\tab Violations are the result of copy-pasting code or incomplete classes (violate SRP), but also over-specialization of classes\\
\section{10/4}
React\\
Learn the HTML Document Object Model (DOM)\\
What are web apps? Website that changes depending on what the user does - dynamic web site\\
\tab Content is interactive\\
Webpages are trees\\
Old way was to remake the tree and reload the page\\
Modern way is to manipulate the DOM\\
React: don't write HTML directly, write code that emits HTML\\
\tab React is a framework\\
\tab A software framework is an abstraction in which software, probiding generic functionality, can be selectively changed with additional user specified code\\
Instead of writing code in order, write the functions, and framework calls functions in the right order\\
Frameworks are "opinionated" - designer of a framework has a way they want you to write code\\
Benefits of a framework: \\
\tab Provides useful defaults, standard behaviour
Downsides: \\
Have to understand how the framework works\\
Knowledge will be incomplete\\
\section{10/7}
Design Patterns\\
Same problems in multiple contexts\\
"each pattern represents our current best guess as to what arrangement of the physical environment will work to solve the problem presented. The empirical
questions center on the problem---does it occur and is it felt in the way we describe it? ---and the solution---does the arrangement we propose solve the problem?"\\
Object-oriented design patterns: so common\\
Each pattern solves certain problems, but not all problems can be solved with named patterns\\
Factory pattern: \\
\tab Object needs to be hooked up, or which object to create depends on something\\
\tab Repeating this pattern violates DRY, so put the logic in a "factory"\\
Singleton Pattern:\\
\tab Sometimes there should only be one of something - only one "factory"\\
\tab Other examples: logger, cache, thread pool\\
\tab Use sparingly; a lot like global variables\\
\tab Private constructors are a good example\\
Observer Pattern:\\
\tab Multiple different ways to update one model - different controllers\\
\tab Model stores state\\
\tab Views need to know state, but the model shouldn't have to communicate to the different views through controllers\\
\tab Controllers have to know about the model, but the model shouldn't have to know about the controllers\\
\tab Model has a notification center, and the controllers \textbf{listen} to the notification center\\
\tab Controllers are the Observers
\section{10/9}
Why study HCI?
\tab Software Engineering is about meeting user Needs\\
\tab Building the wrong software is costly\\
\tab Apply principles of HCI, iterate, hire a designer\\
Contextual design: People are experts at their own work, but can't articulate their work process\\
\tab Observe people in their work environment\\
\tab Build personas to bring users alive\\
\tab \tab Personas build empathy, help you think like the user, but are not necessarily real people\\
\tab Design a prototype with Figma\\
Principles: \\
\tab Ways of assessing designs: usability studies, "discount methods" (users are expensive)\\
Nielsen's 10 Usability Heuristics: \\
\tab From 1994, but still relevant\\
\tab No need for user tests, instead, need an expert evaluator\\
\tab Goal is to identify usability problems\\
\begin{itemize}
    \item Visibility of system status: keep users informed about what is going on; progress indicators
    \item Match between system and the real world: speak the user's language, follow real-world conventions
    \item User control and freedom: undo, redo, escape, exit
    \item Consistency and standards: follow platform conventions - people use other products more than yours
    \item Error prevention: eliminate error-prone conditions, check for errors, confirm before destructive actions
    \item Recognition rather than recall: minimize memory load, make objects, actions, and options visible
    \item Flexibility and efficiency of use: accelerators, shortcuts (hidden from novice users), allow users to tailor frequent actions: 
    novices need discoverability; experts need efficiency
    \item Aesthetic and minimalist design: don't include information that is irrelevant or rarely needed
    \item Help users recognize, diagnose, and recover from errors: error messages in plain language, precisely indicate the problem, constructively suggest a solution
    \item Help and documentation: even though it is better if the system can be used without documentation, it may be necessary to provide help and documentation:
    enable search in documentation, present documentation in context
    \begin{itemize}
        \item Proactive help: provide help before the user gets stuck (tutorials): Push - not relevant to user goals, pull - relevant to user goals
        \item Reactive help: provide help when the user gets stuck (error messages, FAQ)
    \end{itemize}
\end{itemize}
\section{10/14}
Process: \\
\tab Software Process: a set of activities and associated results that produce a software product\\
How to develop software?\\
\tab Discuss the software that needs to be written\\
\tab write some code\\
\tab test the code\\
\tab debug the code to find causes of defects\\
\tab fix the bugs
Productive development: (coding, testing, making progress towards goals)\\
Not spending effort into addressing inefficiences and following process leads to more work later on\\
Hypothesis: Process increases efficiency and flexibility\\
\tab Ideal curve is upfront investment in process for later returns\\
Estimating time is hard\\
How to measure progress?\\
\tab Developer judgement, lines of code, functionality, quality\\
Milestones and Deliverables make progress observable\\
Milestone: Clear end point of a (sub)task(s)\\
\tab For a project manager; reports, prototypes, completed subprojects\\
Deliverables: Result for customer\\
\tab Similar to milestones, but for customers\\
Waterfall Model: \\
\tab Requirements, design, implement, verification, maintenance\\
Need to center around rapid feedback instead\\
Lean production: adapt to variable demand\\
\tab Build only what is needed, when it is needed\\
\tab Use "pull" system to avoid overproduction\\
\tab Stop to fix problems to prevent defects from propogating\\
\tab Workers are multi-skilled and can understand the whole process; take ownership\\
\tab \tab Just-in-time, DevOps, Shift-Left\\\\
Agile Overview: \\
\tab Keep a prioritized list of user stories in a backlog\\
\tab \textbf{Product owner} sets priorities in backlog\\
\tab Divide work into sprints (2ish weeks)\\
\tab Conceptually, at the end of each sprint, you could ship\\
\tab The \textbf{scrum master} keeps progress on track; removes barriers to success\\\\
Sprint structure: \\
\tab Start with planning meeting\\
\tab Estimate user stories, commit to them individually\\
\tab Daily standup meetings: what did I do yesterday, what will I do today, am I stuck\\
\tab Then sprint review and sprint retrospective\\\\
Sprint Review: \\
\tab For each user story, demo\\
\tab If acceptance criteria are met, story is done, else it goes back to the backlog\\\\
Sprint Retrospective: \\
\tab Discuss how the sprint went, refine iterations, processes, tools; identify and solve problems; decide on changes to improve effectiveness\\
\section{10/16}
Testing:\\
\tab Defining correct behaviour\\
Purposes of testing: \\
\tab Find bugs\\
\tab Prevent bugs from sneaking in when enhancing\\
\tab Give high confidence in correctness\\
\tab Explore class/method design\\
\tab Specify expected behaviour\\
Three big ideas: \\
\tab Coverage: seek to execute all possibilities\\
\tab Test equivalence classes: tests should all cover different things\\
\tab Bottom-up testing: test the smallest things first, when testing things you shouldn't have to test the components\\
Black box vs White box testing: \\
\tab Black box: test the software without knowing the internal structure\\
\tab \tab Not biased by implementation details, can't leverage opportunities\\
\tab White box: test the software with knowledge of the internal structure\\
\tab \tab Can exploit bugs, will miss "impossible" bugs\\
Agile Testing (hierarchical, diverse): \\
\tab 3 kinds of tests, bottom up: \\
\tab \tab Unit tests: test individual classes and methods (task level)\\
\tab \tab Integration tests: test how classes work together, BDD personality tests (story level)\\
\tab \tab End-to-end scenario tests: (milestone level)\\
Mocking as a way to test\\
\tab Testing can only show the presence of bugs, not the absence\\
Fuzz testing: security and robustness\\
\tab Bugs don't always result in crashes\\
\tab \tab Automatic oracles: sanitizers\\
Pros: cheap to generate inputs, easy to debug when issues are found\\
Cons: hard to know when to stop, hard to know if you've found all the bugs, random inputs don't make sense\\
\section{10/18}
Software Architecture:\\
\tab High-level design of a software system\\
\tab Structure of the system, includes software elements, externally visible properties, relationships between them\\
Two kinds of requirements: \\
\tab Functional requirements: what the system should do\\
\tab Quality attributes: the degree to which the software works as needed\\
\tab \tab Modifiability, performance, scalability, availabilty, usability, maintainability, etc.\\
Levels of abstraction: \\
\tab Requirements: what needs to be done\\
\tab Architecture: how it will be done, mid-level "what"\\
\tab OO-Design (low level): mid-level how it will be done, low-level "what"\\
Views: \\
\tab Different ways of looking at the same system\\
Why document architecture?\\
\tab Blueprint for the system, helps with maintenance\\
\tab Documents architect's knowledge/decisions\\
\tab Supports traceability\\
Each view alights with a purpose\\
\tab Only represents info relevant to the purpose\\
\tab Different views for different reasoning models\\
Module views (static): \\
\tab Shows structure defined by the code\\
\tab Modules (systems, subsystems) and their relations (dependencies)\\
\tab Often shows decompositions (what contains what) and uses (what calls what)\\
\tab \tab Composition: has to include the other\\
\tab \tab Aggregation: can exist without the other\\
\tab UML for the diagram\\
Component views (dynamic): \\
\tab Shows entities at runtime\\
\tab Components (processes, runnable entities) and their connectors (data flow, messages)\\
\tab Do not exist until program runs, can't be shown in static view\\
Physical view (deployment): \\
\tab Hardware structures and their components\\
\tab What parts of the system run on which physical machines\\
\tab How do those machines connect\\

\section{10/21}
Reminder that software architecture is about promoting quality attributes,
sometimes at the expense of other quality attributes
A \textit{style} is a class of architecture with a typical structure
\begin{itemize}
    \item Pipes and filters: "Data flow" family of styles
    \begin{itemize}
        \item Ex. Compilers - language source code to compiler to intermediate code optimizer to machine code
        \item UNIX Pipes: filters are processes (different ports), pipes are buffered streams
        \item Difference with procedures - control is asynchronous and data-driven rather than synchronous and blocking;
        semantics are functional rather than hierarchical, data is streamed rather than parameter/return value
        variations include buffering, EOF behavior as opposed to binding time, exception handling, polymorphism
        \item Analysis: promotes modifiability (can insert/remove filters, redirect pipes), reuse, and performance (parallel computing)
        \item Inhibits usability (harder to build interactive apps this way), performance (translating data to send through pipes), cost
        (writing filters complex due to common pipe data format), correctness (synchronizing across pipes)
    \end{itemize}
    \item Layered Styles: layers of useful systems, basic utility, and core level
    \begin{itemize}
        \item Ex. Internet protocol suite
        \item Static entities (classes, modules)
        \item Constraint: only invoke code at lower levels; variation is only next level down
        \item Benefits: changes only affect layers above, not whole system, and can reuse (swap implementation of layer)
        \item Considerations: hard to choose right layers, what layer does which code go in
    \end{itemize}
    \item Tiers: organize clients and servers into tiers - provide services above, rely on services below
    \begin{itemize}
        \item Seen in runtime view, as opposed to layers seen in module/static view
        \item Promotes: security (user can't access data directly), performance (separate tiers on separate hardware), availabilty (replicate tiers)
        \item Rules: Each componenet in exactly one tier, can use services in lower tier/next tier down, depending on variation, can or can't use components on same tier
        \item Advantages: tiers reflect clean abstractions, promotes reuse
        \item Disadvantages: unclear which tier components belont to, what if they fit multiple, performance implications motivate inappropriate connections around layers (tunneling)
        \item Tunneling: connection between layers not next to each other - violates layering, but is convenient and can improve performance
    \end{itemize}
    \item Client-Server Architecture: clients know who the server is, server knows little about clients with previously agreed upon protocol
    \begin{itemize}
        \item Promotes: scalability (easy to add more clients, servers), modifiability (can swap out clients and servers separately)
        \item Inhibits: reliability (server/network may be down), performance (network bandwidth, latency), security (open ports), simplicity (more failure modes to test)
        \item Publish-Subscribe style (Implicit Invocation): publishers don't know who is subscribed
        \begin{itemize}
            \item Benefits: decouples publishers from subscribers, promotes reuse because adding a component just requires registering it for events
            \item Problems: Order of event delivery not guaranteed; causes bugs when order is depended on; choose between synchronous or asynchronous event processing
        \end{itemize}
    \end{itemize}
\end{itemize}
\section{10/23}
Focus on Modifiability: before deployment\\
Responsibilities: action, knowledge to be maintained, or decision to be carried out by software system or element of the system\\
\tab Responsibilities are assigned to modules; what is the cost of modifiying a responsibility?\\
\tab Coupling: cost of modifiying module depends on how tightly-coupled it is to other modules\\
\tab \tab Reducing coupling may reduce modification costs - minimize relationships among elements not in same module, maximize relationships among elements in same module\\
\tab \tab Cohesion: put related responsibilties in the same module\\
\tab Maximize cohesion and minimize coupling\\
Tactics: \\
\tab Reduce cost of modifiying a singe responsibility by splitting it\\
\tab \tab Split responsibility so the new modules can be modified independently; enables deferred binding (replacing a module at runtime)\\
\tab Increase cohesion by maintaining semantic coherence and abstracting common services\\
\tab \tab More responsibilities from one module to another, put related responsibilities together\\
\tab Reduce coupling by using encapsulation, using a wrapper, raising the abstraction level, using an intermediary, or restricting communication paths\\
\tab \tab Encapsulation: hide information with an interface\\
\tab \tab Wrapper transforms invocations, difference between wrapper and encapsulation a little fuzzy\\
\tab \tab Raise abstraction level by adding parameters to interface; makes module more abstract, enables flexibility\\
\tab \tab Intermediary: restricts communication paths, breaks direct dependencies by adding one in between\\
\section{10/28}
Code Review: \\
Why Code Review?\\
\tab Testing has limitations: costly to get 100\% coverage; use 80/20 rule\\
\tab Not all properties can be checked at runtime: good design, simple implementation, understandable code, follows coding conventions, UI looks as intended, follows UI guidelines, are tests adequate?\\
Code review: systematic reading/examination of the code\\
\tab Focused on what can't be tested\\
\tab Usually done asynchronously, at least one is non-author, work through complex problems like design\\
\tab Pair programming is instantaneous code review\\
\tab Bus factor: how many people need to be hit by a bus for the project to fail\\
Previously: formal code review (inspection)\\
\tab Sit in meeting, read all code - effective at finding bugs, too slow for practical use\\
\tab Modern code review: change-based code review - every change gets reviewed by someone\\
Purposes of code review: find defects, code improvement, alternative solution, knowledge transfer, team awareness, improving dev process, share code ownership, avoid build breaks track rationale, team assessment\\
Code review at Google: each directory is owned by some people; owners must review and approve changes\\
\tab "Readability": some developers are "readability" certified - each change must be reviewed by someone certified in that language\\
Create a change, preview results of static analyzers, reviewers write comments, unresolved comments must be addressed, feedback is addressed, and reviewers mark as "LGTM" (looks good to me)\\
Few commits, few number of lines modified per change\\
Split changes into multiple smaller commits\\
Tone: code is team's code, not the author's code; use "we" language, not :you" language\\
\tab Avoid blame - use "what if"s
Subject of the review is the code itself, not the design\\
Questions are not very helpful in code review\\
Most useful comments: \\
\tab Identification of functional issues (rare, bery useful)\\
\tab Validation issues, corner cases\\
\tab For new developers: API suggestions, design ideas, coding conventions\\
\tab Somewhat useful: nit-picking (identifier naming, comments); refactoring ideas\\
\tab Not useful: questions, future tasks\\
Systematic review: \\
\tab Checklists: what to look for\\
\tab Specific techniques for specific issues\\
\tab Use tools in GitHub or IDE\\
\section{10/30}
Integrating security into the development workflow, and technical risks and mitigations\\
Old methods: write code, give to security people, then let operations people host it\\
\tab Usually too late to fix security issues; security has architectural implications\\
DevSecOps: integrate security into the development workflow\\
Kinds of security challenges: \\
\tab Undefined behavior - don't use unsafe languages\\
\tab Incorrect security-related code - review, test, control changes\\
\tab Higher-level design mistakes - architectural review, penetration testing\\
\tab Users (social engineering) - HCI techniques, training, compromise procedures\\
Train, define security requirements, define metrics and compliance reporting, use software composition analysis and governance, 
perform threat modeling, use tools and automation, keep credentials safe, use continuous learning and monitoring\\
Security requirements: \\
\tab Legal and industry requirements\\
\tab Internal standards and coding practices(strcpy)\\
\tab Review of previous incidents and known threats\\
\tab Traditional requirements analysis with security focus\\
Metrics and Compliance reporting: \\
\tab How will you know whether you've succeeded? Does one breach mean you've failed? Better to focus on progress than success/failure\\
Threat modeling: \\
Goal: enumerate all possible threats; use STRIDE model to identify threats\\
\tab Spoofing identity: attacker pretends to be someone they are not\\
\tab Tampering with data: changing data in the system\\
\tab Repudiation: lying about something done\\
\tab Information disclosure: unauthorized access to data\\
\tab Denial of service: making the system unusable\\
\tab Elevation of privilege: gaining access to something you shouldn't have\\
Software composition analysis and governance:\\
\tab Vulnerabilities in third-party libraries\\
Use Tools and Automation: \\
\tab Integrate tools into CI/CD pipeline\\
\tab Must not require security expertise\\
\tab Must avoid a high false-positive rate\\
Keep credentials safe: \\
\tab Scan for keys in source code\\
\tab Put keys in a .env file\\
\tab Put .env in .gitignore\\
Use continuous learning and monitoring: \\
\tab Continuous integration/delivery\\
\tab Run analyses automatically\\
\tab Mean time to identify, mean time to contain\\
Top 10 Threats (OWASP)\\
Broken access control, cryptographic failures, injection, insecure design, security misconfiguration, vulnerable and outdated components, 
identification and authentication failures, software and data integrity failures, security logging and monitoring failures, server-side request forgery\\
Mitigating key threats: \\
Untrusted Data: \\
\tab Injection attacks: validate input, avoid eval(), sanitize inputs when constructing SQL queries\\
\tab \tab Cross site scripting attack (XSS): untrusted data enters app, data included in content sent to user\\
\tab Bad authentication: use TLS to check server certificate, check user credentials\\
\tab \tab Authentication vs Authorization: \\
\tab \tab \tab Authentication: are you who you say you are?\\
\tab \tab \tab Authorization: given who you are, are you allowed to do what you're trying to do? Needs access control\\
\tab \tab letsencrypt.com: free certificates\\
\tab \tab Password cracking: \\
\tab \tab \tab Brute force to try all strings: use large space of passwords, avoid commonly used passwords\\
\tab \tab \tab Rainbow table attack (precompute hashes of common passwords): use large space of passwords, avoid commonly used passwords\\ 
\tab \tab \tab Salts: users with same password have different salts, so same password doesn't have same hash; random salts added to user passwords\\
\tab \tab Passwords do not go in the repo or database! Passwords in config files, hashed passwords in database\\
Principle of Least Privilege: \\
\tab Only authorize access that is needed\\
Defense in Depth: \\
\tab Don't have just one security check; encrypt traffic and restrict access by VPN\\
\section{11/4}
Debugging large software systems:\\
Avoidance path: some bugs can't be fixed by delivery date\\
Sometimes bugs are encoded in the specifications\\
\tab Either change the code or change the specifications\\
Judge costs, assess risks, and measure severity\\
Fixing bugs risks introducing regressions\\
Bug reports shoud show how to reproduce bug, what the observed behavior is\\
Two phases: fault localization (where bug occurs) and fault repair (what to do about it)\\
Be deliberate: one bug at a time, write test cases, commit after each bug\\
\tab Fault localization is most of the work\\
\tab Come up with hypotheses, test them according to likelihood and ease of elimination\\
\tab \tab Goal is to fix the bug while understanding no more than necessary; assuming that reading all code is impossible\\
Test case minimization:\\
\tab Remove all elements of the test case that are unnecessary to reproduce the bug\\
Narrowing down the responsible code: \\
\tab Replace modules with mock modules that do the right thing\\
\tab Try to show the bug is in the framework you're using, or you learn what the bug actually is\\
Divide and conquer: \\
\tab Bug is either because component doesn't do what it's supposed to, or it's not what some other component needed\\
\tab Be explicit about assumptions (preconditions), and expectations (postconditions)\\
Regressions: use git bisect to fix\\
Bad state: after doing X, some state is wrong.\\
\tab Sprinkle assertions throughout code for X; find exactly where the state is wrong\\
No clue where to start: search code for relevant words, ask expert, git blame\\
Unusual situations:\\
Heisenbugs: bugs that disappear when you try to debug them\\
Usual suspects: race conditions (timing matters), compiler optimizations, hardware failures\\
Careful recording: can't keep track of everything in your head:\\
\tab Record each hypothesis, test inputs and results and conclusion\\
\tab Change one thing at a time\\
\section{11/6}
\textbf{Risk} is essential to software engineering: every bug costs more to fix later, but fixing bugs may introduce new bugs\\
Technical risks: choosing to rely on a framework that's "almost done" but runs late; rely on a platform/service/framework that does not meet needs
/adds complexity without adding value; underestimate the complexity of your own components\\
Financial risks: running out of money (startup), getting sued, need to give raises for retention but now can't afford to hire more people\\
Requirements risks: releasing software that does not meet user needs (even if it's high quality), or if it frustrates users, or if it is released too late\\
People-related risks: by choice (better job offer), by circumstance (disaster), being fired, being stolen by Management to work on a higher priority project\\
Management-related risks: management changes priorities, de-prioritizes features you invested in, prioritizes features you didn't invest in, management turnover (spends time managing up (managing the manager))\\
Osborne effect: announcing a product too early, causing sales of current product to drop\\
Mythical Man Month: book by Fred Brooks\\
\tab Brooks' Law: Adding people to a late project makes it later\\
\tab New people consume resources getting up to speed, introduce new bugs, reintroduce old bugs, increases communication overhead\\
Group intercommunication formula: n(n-1)/2\\
\tab Need to keep teams small\\
Second System Effect: the first time you design something, you know you don't know what you're doing\\
\tab The second time, you think you know, and you fix all the things that were wrong the first time\\
\tab The second system is the riskiest\\
Incremental slippage: continually delaying by a day causes a year delay\\
Awareness-Understanding matrix: \\
\tab Aware + Understand: Known knowns: things you know you know\\
\tab Aware + Don't Understand: Known unknowns: things you know you don't know\\
\tab Unaware + Understand: Unknown knowns: things you aren't aware of but you know implicitly\\
\tab Unaware + Don't Understand: Unknown unknowns: things you don't know you don't know\\
Inherent vs Accidental complexity: complexity is a source of risk\\
\tab Inherent complexity: complexity that is inherent to the problem - tax software has to be as complex as tax law\\
\tab Accidental complexity: complexity that is not inherent to the problem - making the problem harder than it should be\\
Conway's Law: Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations\\
\tab If you have 3 teams working on a project, there will be 3 separate modules\\
\tab Organizational structure poses architectural risks\\
Surfacing risks: ask team members what might go wrong (diverse team more likely to identify risks), make mitigation plans
\section{11/8}

\end{document}
